<!doctype HTML>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="setup-page.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Recitation 11: Working with Stacks, Queues and Trees</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra-styles.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CSAS-<wbr></wbr>2123
<br/>
Introduction to Object-<wbr></wbr>Oriented Design</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="General.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="Recitations.html" class="tocviewselflink" data-pltdoc="x">Recitations</a></td></tr><tr><td align="right"></td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right"></td><td><a href="Pair_Programming_Overview.html" class="tocviewlink" data-pltdoc="x">Pair Programming Overview</a></td></tr><tr><td align="right"></td><td><a href="code-style.html" class="tocviewlink" data-pltdoc="x">Code style</a></td></tr><tr><td align="right"></td><td><a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="Recitations.html" class="tocviewlink" data-pltdoc="x">Recitations</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="recitation1.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 1:</span> Introduction to Intelli<span class="mywbr"> &nbsp;</span>J and Simple Data Definitions</a></td></tr><tr><td align="right"></td><td><a href="recitation2.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 2:</span> Working with Self-<wbr></wbr>Referential Data</a></td></tr><tr><td align="right"></td><td><a href="recitation3.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 3:</span> Methods for Complex Data</a></td></tr><tr><td align="right"></td><td><a href="recitation4.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 4:</span> Working with Abstract Classes, Problem Solving</a></td></tr><tr><td align="right"></td><td><a href="recitation5.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 5:</span> Custom Constructors and Equality</a></td></tr><tr><td align="right"></td><td><a href="recitation6.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 6:</span> Designing a simple game</a></td></tr><tr><td align="right"></td><td><a href="recitation7.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 7:</span> Parametric data and visitors</a></td></tr><tr><td align="right"></td><td><a href="recitation8.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 8:</span> Understanding Mutation</a></td></tr><tr><td align="right"></td><td><a href="recitation9.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 9:</span> Working with Cyclic Data</a></td></tr><tr><td align="right"></td><td><a href="recitation10.html" class="tocviewlink" data-pltdoc="x"><span class="RecitationNum">Recitation 10:</span> Imperative Worlds</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="RecitationNum">Recitation 11:</span> Working with Stacks, Queues and Trees</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="RecitationNum">Recitation 11:</span> Working with Stacks, Queues and Trees</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Stacks_and_.Queues%29" class="tocviewlink" data-pltdoc="x">Stacks and Queues</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Binary_trees%29" class="tocviewlink" data-pltdoc="x">Binary trees</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Iterators_and_.Iterables%29" class="tocviewlink" data-pltdoc="x">Iterators and Iterables</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Challenge__iterating_through_a_binary_tree%29" class="tocviewlink" data-pltdoc="x">Challenge:<span class="mywbr"> &nbsp;</span> iterating through a binary tree</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Stacks_and_.Queues%29" class="tocsubseclink" data-pltdoc="x">Stacks and Queues</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Practice_puzzle%29" class="tocsubseclink" data-pltdoc="x">Practice puzzle</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Binary_trees%29" class="tocsubseclink" data-pltdoc="x">Binary trees</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Iterators_and_.Iterables%29" class="tocsubseclink" data-pltdoc="x">Iterators and Iterables</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Challenge__iterating_through_a_binary_tree%29" class="tocsubseclink" data-pltdoc="x">Challenge:<span class="mywbr"> &nbsp;</span> iterating through a binary tree</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.10</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="recitation10.html" title="backward to &quot;Recitation 10: Imperative Worlds&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Recitations.html" title="up to &quot;Recitations&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Assignments.html" title="forward to &quot;Assignments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._)"></a><span class="RecitationNum">Recitation 11:</span> Working with Stacks, Queues and Trees</h4><p><span style="font-weight: bold">Goals:</span> This lab will practice fundamental algorithms using stacks, queues, and trees.
It will also practice working with iterators (which in turn may use stacks and queues).</p><p>Copy your implementation of Deques from <a href="assignment7.html" data-pltdoc="x"><span class="AssignmentNum">Assignment 7:</span> Cyclic Data and Encoding</a> into a new project. </p><h5>1<tt>&nbsp;</tt><a name="(part._.Stacks_and_.Queues)"></a>Stacks and Queues</h5><p>Stacks and Queues are data structures that look much like mutable lists, where we restrict
how we add and remove items to and from the list.</p><p>A <span class="emph">stack</span> is a mutable list where we are permitted only to access the head of the list:
we can add an item to the head of the list, or we can remove an item from the head of the list,
and we can determine if a stack is empty.  The canonical example of stacks are piles of
dishes: we can only access the topmost dish, and to access the bottom plates we have to remove the top ones first.
Stacks are described as &ldquo;last-in-first-out&rdquo;: the last item that was added to the stack is the first one that gets
removed.</p><p><div class="SIntrapara">In a separate file from your Deque implementation, implement the following class:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Stack</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">push</span><span class="ProfjKeyword">(</span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// adds an item to the head of the list
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">pop</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// removes and returns the head of the list
</span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div></p><p>You are not to modify the implementation of Deque at all (except to fix bugs in your code, if you find any).
In particular, you are not to rely on the particulars of Sentinels and Nodes and such; treat Deque
as an opaque black box that you can only manipulate via its methods.</p><p>A <span class="emph">queue</span> is a mutable list where we are permitted only to add items to the tail of the list,
remove items from the head of the list, and determine if the queue is empty.  Queues are
described as &ldquo;first-in-first-out&rdquo;: the first item that gets added to a queue is the first one that gets removed.
The canonical example of a queue is waiting on line: people enter the line from the back, shuffle forward until they are
at the front of the line, and exit the line at the front.</p><p><div class="SIntrapara">Implement the following class:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Queue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">enqueue</span><span class="ProfjKeyword">(</span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// adds an item to the tail of the list
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dequeue</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// removes and returns the head of the list
</span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div></p><h5>1.1<tt>&nbsp;</tt><a name="(part._.Practice_puzzle)"></a>Practice puzzle</h5><p><div class="SIntrapara">Using two for-each loops and either a stack or a queue as a temporary storage space (only one of them will work),
define the method that reverses an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Utils</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">reverse</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">source</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">If you use a stack, then you can only use the methods push, pop and isEmpty; if you use a queue, you can only use
the methods enqueue, dequeue and isEmpty.</div></p><h5>2<tt>&nbsp;</tt><a name="(part._.Binary_trees)"></a>Binary trees</h5><p>A binary tree is either a Leaf, or a Node containing a value, a left subtree and a right subtree.
Define the (empty) interface <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">INumBinTree</span><span class="RktMeta"></span></span></span> and classes <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumNode</span><span class="RktMeta"></span></span></span> and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span>.  For now,
we will only work with trees containing numbers as their values.</p><p>Define a helper method <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">isLeaf</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> that returns true for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span> objects.
Define a helper method <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumNode</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">asNode</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> that returns <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumNodes</span><span class="RktMeta"></span></span></span> but throws an error on <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span> values.
We&rsquo;ll need these two helpers later.</p><p>A <span class="emph">binary search tree</span> is a binary tree where every value in the left subtree of a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumNode</span><span class="RktMeta"></span></span></span> is
less than the value at the node, every value in the right subtree of a node is greater than the value
at the node, and each subtree is itself a valid binary search tree.  (For now, assume there are no duplicate values anywhere in the tree.)
This property is called an <span class="emph">invariant</span>, because it is a requirement that must always be maintained.</p><p>Note that all binary search trees are binary trees, but not all binary trees are binary search trees.
Therefore, define the method <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">validBST</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> in the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">INumBinTree</span><span class="RktMeta"></span></span></span> interface that returns <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">true</span><span class="RktMeta"></span></span></span> if the tree
upholds the binary search tree invariant.</p><p>Define the method <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">INumBinTree</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">insertBST</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">num</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> that produces a new binary search that results from inserting a new value
into this binary search tree.  You should assume in your implementation that the binary search tree invariant holds on the current tree,
and you must ensure that the invariant holds on the output tree.</p><h5>3<tt>&nbsp;</tt><a name="(part._.Iterators_and_.Iterables)"></a>Iterators and Iterables</h5><p><div class="SIntrapara">The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Iterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> interface is responsible for producing a sequence of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">T</span><span class="RktMeta"></span></span></span> values, and the interface is defined
by Java as
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">interface</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Iterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// returns true if there's at least one value left in this iterator
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasNext</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// returns the next value and advances the iterator
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// IGNORE THIS FOR NOW
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">Since you must implement all three methods to properly implement this interface, to implement <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, you should <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">throw</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">UnsupportedOperationException</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></span></span>.</div></p><p><div class="SIntrapara">The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Iterable</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> interface asserts that a given object can be iterated to produce a sequence of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">T</span><span class="RktMeta"></span></span></span> values.  It is defined by Java as
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">interface</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Iterable</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Iterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">iterator</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">Classes that implement this interface must supply some <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Iterator</span><span class="RktMeta"></span></span></span> object that can then be used to iterate over themselves.</div></p><p><div class="SIntrapara">In your implementation of Deque, implement a class <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ForwardDequeIterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> that iterates through the Nodes and Sentinel
of a Deque.  It should contain a field <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">curr</span><span class="RktMeta"></span></span></span> that is a reference to an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ANode</span><span class="RktMeta"></span></span></span>.
</div><div class="SIntrapara"><ul><li><p>If <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">curr</span><span class="RktMeta"></span></span></span> refers to a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Node</span><span class="RktMeta"></span></span></span>, then <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">hasNext</span><span class="RktMeta"></span></span></span> should
return true, and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> should return the value in that <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Node</span><span class="RktMeta"></span></span></span>.  It should also update <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">curr</span><span class="RktMeta"></span></span></span> to refer to the next node
in the Deque.</p></li><li><p>If <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">curr</span><span class="RktMeta"></span></span></span> refers to the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Sentinel</span><span class="RktMeta"></span></span></span>, then <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">hasNext</span><span class="RktMeta"></span></span></span> should return false.</p></li></ul></div></p><p>Revise the definition of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span> to say it <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">implements</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Iterable</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span>.  Implement the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">iterator</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> method
to return a new <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ForwardDequeIterator</span><span class="RktMeta"></span></span></span>.</p><p><div class="SIntrapara">If you&rsquo;ve built your iterator correctly, then you should now be able to use a Deque in a for-each loop:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjComment">// In ExamplesDeque
</span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">testDequeIteration</span><span class="ProfjKeyword">(</span><span class="ProfjType">Tester</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">t</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjPrimType">String</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dq</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjPrimType">String</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">dq</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtTail</span><span class="ProfjKeyword">(</span><span class="ProfjString">", "</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">dq</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjString">"Hello"</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">dq</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtTail</span><span class="ProfjKeyword">(</span><span class="ProfjString">"world!"</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">String</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">msg</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjString">""</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">String</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">s</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dq</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">msg</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">msg</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">concat</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">s</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">t</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">checkExpect</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">msg</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjString">"Hello, world!"</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div></p><p>Implement another class <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ReverseDequeIterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> that iterates backward through the Nodes and Sentinel of a Deque.  (Hint: it should be just a tiny
change from the forward iterator!)  Add a method to Deque to return a reverse-iterator (since you already have a method that returns a forward-iterator).</p><p>Write a while loop that tests using a reverse iterator on a Deque.</p><h5>4<tt>&nbsp;</tt><a name="(part._.Challenge__iterating_through_a_binary_tree)"></a>Challenge: iterating through a binary tree</h5><p><div class="SIntrapara">To iterate through a binary tree, we have to maintain a &ldquo;todo list&rdquo; of nodes in the tree that we have yet to process.
Define a class <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">BreadthFirstIterator</span><span class="RktMeta"></span></span></span> that implements <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Iterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span>:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">BreadthFirstIterator</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">implements</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Iterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Queue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">NumNode</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">todoList</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Queue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">NumNode</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">The constructor for a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">BreadthFirstIterator</span><span class="RktMeta"></span></span></span> should take a single <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">INumBinTree</span><span class="RktMeta"></span></span></span>
and enqueue it in the worklist, if it is not a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span>.</div></p><p>The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">hasNext</span><span class="RktMeta"></span></span></span> method should look at the todo list, and determine if it is empty or not.</p><p><div class="SIntrapara">The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> method should:
</div><div class="SIntrapara"><ul><li><p>Deque an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumNode</span><span class="RktMeta"></span></span></span> from the todo list.  It will eventually return the value of this node.</p></li><li><p>If the <span class="emph">left</span> child of the node is not a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span>, enqueue it in the todo list.</p></li><li><p>If the <span class="emph">right</span> child of the node is not a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span>, enqueue it in the todo list.</p></li><li><p>Return the value of the node.</p></li></ul></div><div class="SIntrapara">(Why do we need to enqueue the left child before the right child?)</div></p><p>Revise the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">INumBinTree</span><span class="RktMeta"></span></span></span> interface to extend <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Iterable</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span>.  Implement <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Iterator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">iterator</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>
on <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumNode</span><span class="RktMeta"></span></span></span> and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">NumLeaf</span><span class="RktMeta"></span></span></span>, to return a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">BreadthFirstIterator</span><span class="RktMeta"></span></span></span> as appropriate.  If you&rsquo;ve implemented
it correctly, you should be able to use a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">INumBinTree</span><span class="RktMeta"></span></span></span> with a for-each loop.</p><p>Define another class <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">DepthFirstIterator</span><span class="RktMeta"></span></span></span>, which is just like <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">BreadthFirstIterator</span><span class="RktMeta"></span></span></span> but with two changes:
it should use a Stack instead of a Queue, and it should add the right child before the left child (why?).</p><p>Test both of these iterators.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="recitation10.html" title="backward to &quot;Recitation 10: Imperative Worlds&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Recitations.html" title="up to &quot;Recitations&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Assignments.html" title="forward to &quot;Assignments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>