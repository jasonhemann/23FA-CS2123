<!doctype HTML>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="setup-page.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 9: LightEmAll</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra-styles.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CSAS-<wbr></wbr>2123
<br/>
Introduction to Object-<wbr></wbr>Oriented Design</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="General.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="Recitations.html" class="tocviewlink" data-pltdoc="x">Recitations</a></td></tr><tr><td align="right"></td><td><a href="Assignments.html" class="tocviewselflink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right"></td><td><a href="Pair_Programming_Overview.html" class="tocviewlink" data-pltdoc="x">Pair Programming Overview</a></td></tr><tr><td align="right"></td><td><a href="code-style.html" class="tocviewlink" data-pltdoc="x">Code style</a></td></tr><tr><td align="right"></td><td><a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="assignment1.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 1:</span> Designing complex data</a></td></tr><tr><td align="right"></td><td><a href="assignment2.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 2:</span> Designing methods for complex data</a></td></tr><tr><td align="right"></td><td><a href="assignment3.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 3:</span> Designing methods for complex data; Practice with accumulators</a></td></tr><tr><td align="right"></td><td><a href="assignment4.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 4:</span> Constructors; Structural Equality; Non-<wbr></wbr>structural Equality</a></td></tr><tr><td align="right"></td><td><a href="assignment5.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> A Game, Visitors</a></td></tr><tr><td align="right"></td><td><a href="assignment6.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 6:</span> Cyclic data; Graphs</a></td></tr><tr><td align="right"></td><td><a href="assignment7.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 7:</span> Cyclic Data and Encoding</a></td></tr><tr><td align="right"></td><td><a href="assignment8.html" class="tocviewlink" data-pltdoc="x"><span class="AssignmentNum">Assignment 8:</span> Minesweeper</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 9:</span> Light<span class="mywbr"> &nbsp;</span>Em<span class="mywbr"> &nbsp;</span>All</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 9:</span> Light<span class="mywbr"> &nbsp;</span>Em<span class="mywbr"> &nbsp;</span>All</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="#%28part._.Instructions%29" class="tocviewlink" data-pltdoc="x">Instructions</a></td></tr><tr><td align="right"></td><td><a href="#%28part._.Gameplay%29" class="tocviewlink" data-pltdoc="x">Gameplay</a></td></tr><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Tasks%29" class="tocviewlink" data-pltdoc="x">Tasks</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Extra_credit%29" class="tocviewlink" data-pltdoc="x">Extra credit</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Reference_materials%29" class="tocviewlink" data-pltdoc="x">Reference materials</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Instructions%29" class="tocsubseclink" data-pltdoc="x">Instructions</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Gameplay%29" class="tocsubseclink" data-pltdoc="x">Gameplay</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Tasks%29" class="tocsubseclink" data-pltdoc="x">Tasks</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Setting_up_the_game%29" class="tocsubseclink" data-pltdoc="x">Setting up the game</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Board_generation_strategies%29" class="tocsubseclink" data-pltdoc="x">Board generation strategies</a></td></tr><tr><td><span class="tocsublinknumber">1.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Manual_generation%29" class="tocsubseclink" data-pltdoc="x">Manual generation</a></td></tr><tr><td><span class="tocsublinknumber">1.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Fractal-like_generation%29" class="tocsubseclink" data-pltdoc="x">Fractal-<wbr></wbr>like generation</a></td></tr><tr><td><span class="tocsublinknumber">1.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Random_generation%29" class="tocsubseclink" data-pltdoc="x">Random generation</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Rendering_the_game%29" class="tocsubseclink" data-pltdoc="x">Rendering the game</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Extra_credit%29" class="tocsubseclink" data-pltdoc="x">Extra credit</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Reference_materials%29" class="tocsubseclink" data-pltdoc="x">Reference materials</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Kruskal_s_.Algorithm_for_constructing_.Minimum_.Spanning_.Trees%29" class="tocsubseclink" data-pltdoc="x">Kruskal&rsquo;s Algorithm for constructing Minimum Spanning Trees</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Union_.Find_data_structure%29" class="tocsubseclink" data-pltdoc="x">The Union/<span class="mywbr"> &nbsp;</span>Find data structure</a></td></tr><tr><td><span class="tocsublinknumber">3.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Example%29" class="tocsubseclink" data-pltdoc="x">Example</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.Putting_the_union_find_data_structure_to_work%29" class="tocsubseclink" data-pltdoc="x">Putting the union/<span class="mywbr"> &nbsp;</span>find data structure to work</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.Breadth-_and_depth-first_search%29" class="tocsubseclink" data-pltdoc="x">Breadth-<wbr></wbr> and depth-<wbr></wbr>first search</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.10</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="assignment8.html" title="backward to &quot;Assignment 8: Minesweeper&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Assignments.html" title="up to &quot;Assignments&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Pair_Programming_Overview.html" title="forward to &quot;Pair Programming Overview&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._)"></a><span class="AssignmentNum">Assignment 9:</span> LightEmAll</h4><p><span style="font-weight: bold">Goals:</span> Design a game with mutable world state, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>s, and
loops. Practice working with graphs and graph algorithms by using Kruskal&rsquo;s
algorithm.</p><p>You will be using the Impworld library, as in <a href="recitation10.html" data-pltdoc="x">Recitation 10</a> &#8212;<wbr></wbr> make sure that at
the top of your file, you include</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">import</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">java</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">util</span><span class="ProfjDefault">.</span><span class="ProfjType">ArrayList</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">import</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tester</span><span class="ProfjDefault">.</span><span class="ProfjKeyword">*</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">import</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">javalib</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">impworld</span><span class="ProfjDefault">.</span><span class="ProfjKeyword">*</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">import</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">java</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">awt</span><span class="ProfjDefault">.</span><span class="ProfjType">Color</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">import</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">javalib</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">worldimages</span><span class="ProfjDefault">.</span><span class="ProfjKeyword">*</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>Make sure you do not name any of your files <span class="stt">World.java</span>, or else the
autograder will not be able to compile your code.</p><h5><a name="(part._.Instructions)"></a>Instructions</h5><p>This assignment is long. Start early.</p><p>You will submit this project three times. Submit all the files needed for your
game, in one <span class="stt">.zip</span> file.</p><p>The three submissions will be organized as follows:</p><p><span style="font-weight: bold">Part 1 Due: Monday April 8 at 11:00pm.</span> You must complete the task
of designing and implementing the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span> class &#8212;<wbr></wbr> this includes
connecting <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s to neighboring <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s, drawing
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s, and the click-to-rotate behavior. Your board will be manually
generated.</p><p><span style="font-weight: bold">Part 2 Due: Thursday April 11 at 11:00pm.</span> You must complete the
power-up behavior (where the power station has some finite radius of
effectiveness), drawing the powered lines, and moving the power station when the
arrow keys are pressed. You will generate a fractal-like board using a
subdivision algorithm.</p><p><span style="font-weight: bold">Part 3 Due: Wednesday April 17 at 11:00pm.</span> You must implement Kruskal&rsquo;s
algorithm to generate a random board, plus any additional features or extra
credit you attempt.</p><p>Extra credit will only count if they are convincingly and thoroughly tested,
and if the rest of the assignment is completed equally thoroughly &#8212;<wbr></wbr> you will
not receive extra credit if the minimum functionality does not work properly.</p><h5><a name="(part._.Gameplay)"></a>Gameplay</h5><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>This assignment is based on a game called
<a href="https://www.youtube.com/watch?v=tLjEFrlOjGM">Power Line</a>. The main
difference is that our power station has some finite radius of effectiveness,
and must be moved to ensure power reaches every tile.</p></blockquote></blockquote></blockquote><p>You goal is to light up every tile of the board, by ensuring that all the wires
are connected to the power station. Initially, the board has been scrambled by
randomly rotating each tile:</p><p><img src="lightemall-gameplay1.png" alt="" width="344" height="368"/></p><p>You can click to rotate tiles to join the wires together, but you cannot
move tiles:</p><p><img src="lightemall-gameplay2.png" alt="" width="344" height="368"/></p><p>However, there is more to the puzzle &#8212;<wbr></wbr> the station is only effective up to a
finite radius, and tiles beyond that radius will be unpowered:</p><p><img src="lightemall-gameplay3.png" alt="" width="344" height="368"/></p><p>Therefore, you will have to use the arrow keys to move the power station.
Furthermore, the power station must follow the path created by the wiring. The
player wins when all the tiles are lit up:</p><p><img src="lightemall-gameplay4.png" alt="" width="344" height="368"/></p><h5>1<tt>&nbsp;</tt><a name="(part._.Tasks)"></a>Tasks</h5><p>Here is the list of tasks you will need to complete to implement the game.</p><h5>1.1<tt>&nbsp;</tt><a name="(part._.Setting_up_the_game)"></a>Setting up the game</h5><p>You will need to create a two-dimensional grid of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s to
represent the board. The width and height of the board should be specified as
arguments to your <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">LightEmAll</span><span class="RktMeta"></span></span></span> constructor. Because the size of the board
is configurable, you cannot simply hard-code lists of data, because they may be
of the wrong size. Instead, you&rsquo;ll need to use loops and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>s.</p><p><div class="SIntrapara">The game class will look like the following (but you may need to add additional
fields):
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">LightEmAll</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">extends</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">World</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// a list of columns of GamePieces,
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// i.e., represents the board in column-major order
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">GamePiece</span><span class="ProfjKeyword">&gt;&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">board</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// a list of all nodes
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">GamePiece</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">nodes</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// a list of edges of the minimum spanning tree
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">mst</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// the width and height of the board
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">width</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">height</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// the current location of the power station,
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// as well as its effective radius
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">powerRow</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">powerCol</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">radius</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Effectively, we have created a graph, where each <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>
is a node and the wires are edges.</p></blockquote></blockquote></blockquote><p>Each <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span> represents a tile on the board, and has wires extending
to adjacent <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s. The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">boolean</span><span class="RktMeta"></span></span></span> fields <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">left</span><span class="RktMeta"></span></span></span>,
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">right</span><span class="RktMeta"></span></span></span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">top</span><span class="RktMeta"></span></span></span>, and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">bottom</span><span class="RktMeta"></span></span></span> indicate which neighboring
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s can be connected:</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">GamePiece</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// in logical coordinates, with the origin
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// at the top-left corner of the screen
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">row</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">col</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// whether this GamePiece is connected to the
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// adjacent left, right, top, or bottom pieces
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">left</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">right</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">top</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bottom</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// whether the power station is on this piece
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">powerStation</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>For example, the following <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span> has <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">left</span><span class="RktMeta"></span></span></span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">right</span><span class="RktMeta"></span></span></span>, and
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">bottom</span><span class="RktMeta"></span></span></span> set to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">true</span><span class="RktMeta"></span></span></span>:</p><p><img src="lightemall-tile.png" alt="" width="100" height="100"/></p><p>A <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span> may also have a power station, which supplies power to all
reachable <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>s, up to an effective radius, where the radius is
defined as \((diameter / 2) + 1\). To compute the diameter of your graph,
first run breadth-first search (see below) to determine the last-found
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>. Next, run breadth-first search starting from that last-found
piece and count the depth to the new last-found piece again. That depth is the
diameter of the graph.</p><p>The initial position of the power station will depend on which board generation
strategy you are using.</p><p><div class="SIntrapara">For <span style="font-weight: bold">Part 3</span>, you will need to represent <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Edge</span><span class="RktMeta"></span></span></span>s in your game, so that
you can use Kruskal&rsquo;s algorithm:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">GamePiece</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fromNode</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">GamePiece</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">toNode</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">weight</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div></p><p>The specific wiring of the board can be thought of as a &ldquo;maze&rdquo;, which is
generated by one of three strategies, discussed below. After this step is
complete, the game will shuffle the board, by applying a random number of
rotations to each <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span>.</p><h5>1.2<tt>&nbsp;</tt><a name="(part._.Board_generation_strategies)"></a>Board generation strategies</h5><p>There are three different board generation strategies to implement, one for
each submission.</p><h5>1.2.1<tt>&nbsp;</tt><a name="(part._.Manual_generation)"></a>Manual generation</h5><p>For <span style="font-weight: bold">Part 1</span>, the board will be manually generated, i.e., you will encode
a specific board in the game logic, and every game will have the same solution.
You should choose a simple pattern, such as all vertical lines with a single,
horizontal bar through the center:</p><p><img src="lightemall-hbar.png" alt="" width="344" height="368"/></p><p>Or all horizontal lines with a single, vertical bar through the center:</p><p><img src="lightemall-vbar.png" alt="" width="344" height="368"/></p><p>In both of these boards, the initial position of the power station should
be at the center.</p><h5>1.2.2<tt>&nbsp;</tt><a name="(part._.Fractal-like_generation)"></a>Fractal-like generation</h5><p>For <span style="font-weight: bold">Part 2</span>, you will use a subdivision algorithm to generate
fractal-like wiring.</p><p>The simplest board is a square whose sides are a power of two. The smallest
such board is the base case: a 2&#215;2 grid where the wires form a squared
off U:</p><p><img src="lightemall-fractal1.png" alt="" width="344" height="368"/></p><p>The next case is a 4&#215;4 grid, where each quadrant is the 2&#215;2 base case.
Furthermore, the quadrants are connected in three locations: at the left,
right, and bottom:</p><p><img src="lightemall-fractal2.png" alt="" width="344" height="368"/></p><p>Of course, as the board size increases, the fractal becomes more and more
complex:</p><p><img src="lightemall-fractal3.png" alt="" width="344" height="368"/></p><p>You&rsquo;ll likely want to implement this algorithm in a &ldquo;top-down&rdquo; manner: start
with a grid, subdivide it into four quadrants, recursively generate the wires
in each quadrant, then connect the four quadrants.</p><p>The overall algorithm should be robust so that it can handle non-square grids
and side lengths that are not powers of two.</p><p><span style="font-weight: bold">Hint:</span> Recall how binary search handles the base case. This will be very
similar, but not exactly the same.</p><p>Initially, the power station should be located in the middle of the first row.</p><h5>1.2.3<tt>&nbsp;</tt><a name="(part._.Random_generation)"></a>Random generation</h5><p>For <span style="font-weight: bold">Part 3</span>, you will generate random boards. By treating the wires
as edges on a graph and randomly assigning edge weights, you can use Kruskal&rsquo;s
algorithm (see below) to find the <span class="emph">minimum spanning tree</span>.</p><p>The power station will initially be at the origin, i.e., the top-left corner.</p><h5>1.3<tt>&nbsp;</tt><a name="(part._.Rendering_the_game)"></a>Rendering the game</h5><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span> tiles should be drawn with dark backgrounds. A wire should be
yellow when it is powered, and grey when unpowered.</p><p>You <span style="font-weight: bold">do not</span> need to draw wires getting progressively darker as the
distance from the power station increases. Implementing this functionality is
extra credit.</p><p>The power station should be drawn as a star, on top of the wires.</p><h5>2<tt>&nbsp;</tt><a name="(part._.Extra_credit)"></a>Extra credit</h5><p>If you want to earn extra credit on this assignment, you can complete any
number of &ldquo;whistles&rdquo; and &ldquo;bells&rdquo;.  A &ldquo;whistle&rdquo; is a fairly small
extension to the game; a &ldquo;bell&rdquo; is a more elaborate and impressive
enhancement.  It would take several whistles to be as impressive as a single
bell.  Whistles and bells are not worth a specific number of extra credit
points; they are subjectively graded, and will count toward improving your exam
scores if needed.  (You should therefore aim to implement features that
demonstrate that you have mastered the concepts that you got wrong on your
exams!)</p><p>Whistles and bells will <span class="emph">only</span> count towards extra credit if they are
convincingly and thoroughly tested.  Moreover, the rest of the game must be at
least as well tested &#8212;<wbr></wbr> you will not receive extra credit if the required
parts of the game are not designed properly or do not work properly.</p><p>Here are some examples of whistles and bells:</p><p><div class="SIntrapara"><span style="font-weight: bold">Whistles:</span>
</div><div class="SIntrapara"><ul><li><p>Enhancing the graphics. For example, you could implement the gradient
coloring, as wires get further from the power station. (Very small
whistle!)</p></li><li><p>Allowing the player to start a new puzzle without restarting the
program.</p></li><li><p>Keeping score: how many steps does the player take before connecting
all the wires? Lower scores are better...  You&rsquo;d need to enhance the
display to render the score so far somehow.</p></li><li><p>Or, keeping time: display how long it takes for the player to beat
the game.</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">Bells:</span>
</div><div class="SIntrapara"><ul><li><p><span class="emph">(Tricky!)</span> Construct wiring with a bias in a particular
direction &#8212;<wbr></wbr> a preference for horizontal or vertical wires. (Hint: you
might wish to play tricks with edge weights here.)</p></li><li><p><div class="SIntrapara"><span style="font-weight: bold">Hard! (But very cool)</span> Different wire connectivity: You&rsquo;ve
implemented the board as a connected grid of <span class="emph">squares</span>.  Try
implementing the board as a connected grid of <span class="emph">hexagons</span>.  To do this,
you&rsquo;d need:
    </div><div class="SIntrapara"><ul><li><p>To figure out how to render a hexagon.  See <a href="image-doc.html" data-pltdoc="x">The Image Library</a>.</p></li><li><p>To figure out how to represent a hexagonal grid.  You&rsquo;ll need
to update your <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">GamePiece</span><span class="RktMeta"></span></span></span> class to have six neighbors instead
of four.  You&rsquo;ll also need to figure out how to represent a
hexagonal grid using a normal
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">GamePiece</span><span class="ProfjKeyword">&gt;&gt;</span><span class="RktMeta"></span></span></span>. (Hint: if you look at the
rows of a hexagonal grid, every other row is &ldquo;shifted&rdquo; by half a
cell-width, but there are the same number of cells in every row, so
a regular <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">GamePiece</span><span class="ProfjKeyword">&gt;&gt;</span><span class="RktMeta"></span></span></span> should still
work.)</p></li><li><p>To figure out how to render a hexagonal grid.  You&rsquo;ll need a
little bit of math to figure out the centers of each hexagon.</p></li><li><p>To figure out user-input controls.  I suggest using the
letter &lsquo;a&rsquo;, &lsquo;w&rsquo;, &lsquo;e&rsquo;, &lsquo;d&rsquo;, &lsquo;x&rsquo; and &lsquo;z&rsquo;, to mean their &ldquo;obvious&rdquo;
directions (relative to the letter &lsquo;s&rsquo; on the keyboard).</p></li></ul></div></p></li></ul></div></p><p>You are encouraged and welcome to think of other enhancements to the game; talk
them over with the professors to determine if they are whistles or bells. Have
fun!</p><h5>3<tt>&nbsp;</tt><a name="(part._.Reference_materials)"></a>Reference materials</h5><h5>3.1<tt>&nbsp;</tt><a name="(part._.Kruskal_s_.Algorithm_for_constructing_.Minimum_.Spanning_.Trees)"></a>Kruskal&rsquo;s Algorithm for constructing Minimum Spanning Trees</h5><p>Here is Kruskal&rsquo;s algorithm illustrated on a particular example graph:</p><p><div class="SIntrapara"><pre class="AsciiArt">A -----30------- B -----50------- F
 \             / |               /
  \           /  |              /
  50        35  40            50
    \       /    |            /
     \     /     |           /
      \   /      |          /
        E --15-- C ---25-- D</pre></div><div class="SIntrapara">(The edges are drawn without directional arrows; in your mazes, every maze cell
will be connected to its four neighbors, so edges are effectively undirected.
Edge weights are notated as numbers on the edges.)</div></p><p>Kruskal&rsquo;s algorithm begins by sorting the list of edges in the graph by edge
weight, from shortest to longest:</p><p><div class="SIntrapara"><pre class="AsciiArt">(E C 15)
(C D 25)
(A B 30)
(B E 35)
(B C 40)
(F D 50)
(A E 50)
(B F 50)</pre></div><div class="SIntrapara">At each step we remove the shortest edge from the list and add it to the
spanning tree, provided we do not introduce a cycle.  In practice, this may
produce <span class="emph">many</span> trees during the execution of the algorithm (so in fact,
the algorithm produces a spanning <span class="emph">forest</span> while it runs), but they will
eventually merge into a single spanning tree at the completion of the
algorithm.</div></p><p>For this particular graph, we add the edges <span class="stt">(E C 15)</span>, <span class="stt">(C D 25)</span>,
<span class="stt">(A B 30)</span> and <span class="stt">(B E 35)</span>. When we try to add the edge <span class="stt">(B C 40)</span> we
see that it would make a cycle, so this edge is not needed and we discard it.
We then add edge <span class="stt">(F D 50)</span>. This connects the last remaining unconnected
node in the graph, and our spanning tree is complete.  In very high-level
pseudocode, the algorithm is quite short and elegant:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">while (we do not yet have a complete spanning tree)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">find the shortest edge that does not create a cycle</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">and add it to the spanning tree</span></p></td></tr></table></p><p><div class="SIntrapara">Determining if we have a complete spanning tree is easy: for \(n\) nodes, we
need \(n-1\) edges to connect them all. </div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Why can&rsquo;t we have fewer
edges?  Why can&rsquo;t we have more?</div></p></blockquote></div><div class="SIntrapara"> We can represent the spanning tree itself by a
list of edges.  Adding an edge to that list is as easy as <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Cons</span><span class="RktMeta"></span></span></span>&rsquo;ing it
on, or <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">add</span><span class="RktMeta"></span></span></span>ing it, depending on which representation of lists you choose
to use.  Finding the shortest edge is easy, since we began by sorting the list
of edges by their weights. The only tricky part in this algorithm is figuring
out whether a given edge creates a cycle with the edges we have already
selected. For this we use the Union/Find data structure.</div></p><h5>3.2<tt>&nbsp;</tt><a name="(part._.The_.Union_.Find_data_structure)"></a>The Union/Find data structure</h5><p>The goal of the union/find data structure is to allow us to take a set of items
(such as nodes in a graph) and partition them into groups (such as nodes
connected by spanning trees) in such a way that we can easily <span class="emph">find</span>
whether two nodes are in the same group, and <span class="emph">union</span> two disjoint groups
together.  Intuitively, we accomplish this by <span class="emph">naming</span> each group by some
<span class="emph">representative element</span>, and then two items can be checked for whether
they are in the same group by checking if they have the same representative
element.</p><h5>3.2.1<tt>&nbsp;</tt><a name="(part._.Example)"></a>Example</h5><p>In class, we represented every node of the graph as a class with a
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">String</span><span class="RktMeta"></span></span></span> name field.  (For this assignment, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">String</span><span class="RktMeta"></span></span></span> names will be
inconvenient; you will need to come up with some other uniquely-identifying
feature of each cell in a maze that can serve the same role as a name.)  Then
the union-find data structure was a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjPrimType">String</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">String</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> that mapped
(the name of) each node to (the name of) a node that it is connected to.
Initially, every node name is mapped to itself, signifying that every node is
its own representative element, or equivalently, that it is not connected to
anything.</p><p>Recall the example from above:</p><p><div class="SIntrapara"><pre class="AsciiArt">A -----30------- B -----50------- F
 \             / |               /
  \           /  |              /
  50        35  40            50
    \       /    |            /
     \     /     |           /
      \   /      |          /
        E --15-- C ---25-- D</pre></div><div class="SIntrapara">Our <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="RktMeta"></span></span></span> will map every node name to itself:</div></p><p><div class="SIntrapara"><pre class="AsciiArt">                                     Representatives, visually:
        +---+---+---+---+---+---+    A     B     C     D     E     F
Node:   | A | B | C | D | E | F |
        +---+---+---+---+---+---+
Link:   | A | B | C | D | E | F |
        +---+---+---+---+---+---+


Spanning tree so far:</pre></div><div class="SIntrapara">Kruskal&rsquo;s algorithm begins by sorting the list of edges in the graph by edge
weight, from shortest to longest:</div></p><p><div class="SIntrapara"><pre class="AsciiArt">(E C 15)
(C D 25)
(A B 30)
(B E 35)
(B C 40)
(F D 50)
(A E 50)
(B F 50)</pre></div><div class="SIntrapara">When we add edge <span class="stt">(E C 15)</span>, nodes <span class="stt">E</span> and <span class="stt">C</span> are now connected:</div></p><p><div class="SIntrapara"><pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+     A     B     D     E     F
Node:   | A | B | C | D | E | F |                       ^
        +---+---+---+---+---+---+                       |
Link:   | A | B | E | D | E | F |                       C
        +---+---+---+---+---+---+

Spanning tree so far:          (C E)</pre></div><div class="SIntrapara">We next add edge <span class="stt">(C D 25)</span>.  Since <span class="stt">C</span>&rsquo;s representative is <span class="stt">E</span>, and
<span class="stt">D</span>&rsquo;s representative is <span class="stt">D</span>, they are currently separate, so adding this
edge would not create a cycle.  We can therefore <span class="emph">union</span> them and set
<span class="stt">D</span>&rsquo;s representative&rsquo;s representative to <span class="stt">C</span>&rsquo;s representative:</div></p><p><div class="SIntrapara"><pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+     A     B     E     F
Node:   | A | B | C | D | E | F |                 ^
        +---+---+---+---+---+---+                / \
Link:   | A | B | E | E | E | F |               C   D
        +---+---+---+---+---+---+

Spanning tree so far:          (C D) (C E)</pre></div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Careful! Why must we union the representatives of two nodes, and not
the nodes themselves?</div></p></blockquote></div></p><p>Next we add edge <span class="stt">(A B 30)</span>:</p><p><div class="SIntrapara"><pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+     A     E     F
Node:   | A | B | C | D | E | F |     ^     ^
        +---+---+---+---+---+---+     |    / \
Link:   | A | A | E | E | E | F |     B   C   D
        +---+---+---+---+---+---+

Spanning tree so far:          (A B) (C D) (C E)</pre></div><div class="SIntrapara">We now have three connected components: Nodes <span class="stt">B</span> and <span class="stt">A</span> form one of
them, node <span class="stt">F</span> is a singleton, and nodes <span class="stt">C</span>, <span class="stt">D</span>, and <span class="stt">E</span> are in
the third component.</div></p><p>We add edge <span class="stt">(B E 35)</span>. That means we add a link from the representative for
<span class="stt">B</span> (which is <span class="stt">A</span>) to the representative for node <span class="stt">E</span> (which is
<span class="stt">E</span>):</p><p><div class="SIntrapara"><pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+       E     F
Node:   | A | B | C | D | E | F |       ^
        +---+---+---+---+---+---+      /|\
Link:   | E | A | E | E | E | F |     A C D
        +---+---+---+---+---+---+     ^
                                      |
                                      B

Spanning tree so far:          (A B) (B E) (C D) (C E)</pre></div><div class="SIntrapara">We still have two components.  When we try to add the edge <span class="stt">(B C 40)</span> to the
graph, we notice that the representative for node <span class="stt">C</span> is the same as the
representative for the node <span class="stt">B</span>. Therefore adding this edge would create a
cycle, so we discard it.</div></p><p>Finally, we add the edge <span class="stt">(F D 50)</span>: after this, every node has the same
representative, and therefore all nodes are connected:</p><pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+       E
Node:   | A | B | C | D | E | F |       ^
        +---+---+---+---+---+---+      /|\
Link:   | E | A | E | E | E | D |     A C D
        +---+---+---+---+---+---+     ^   ^
                                      |   |
                                      B   F

Spanning tree so far:          (A B) (B E) (C D) (C E) (D F)</pre><h5>3.3<tt>&nbsp;</tt><a name="(part._.Putting_the_union_find_data_structure_to_work)"></a>Putting the union/find data structure to work</h5><p>The full Kruskal&rsquo;s algorithm needs a union/find data structure to handle
efficiently connecting components, and also needs a list of the edges used by
the algorithm:</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjPrimType">String</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">String</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjType">List</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edgesInTree</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjType">List</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">all</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edges</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">in</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">graph</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">sorted</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">by</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">weights</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjError">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjIdentifier">initialize</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">every</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">node</span><span class="ProfjError">'s </span><span class="ProfjIdentifier">representative</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">itself</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjType">While</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">there</span><span class="ProfjError">'s </span><span class="ProfjIdentifier">more</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">than</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">one</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Pick</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cheapest</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">of</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">graph</span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">suppose</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">it</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connects</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">and</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjDefault">.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">If</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">equals</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">discard</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// they're already connected
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Else</span><span class="ProfjKeyword">:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Record</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">in</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edgesInTree</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">union</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">          </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">          </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjType">Return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edgesInTree</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>To <span class="stt">find</span> a representative: if a node name maps to itself, then it is the
representative; otherwise, &ldquo;follow the links&rdquo; in the representatives map, and
recursively look up the representative for the current node&rsquo;s parent.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>There are additional heuristics for speeding this algorithm up in
practice, and they make for a <span class="emph">very</span> efficient algorithm. Unfortunately,
analyzing these heuristics is beyond the scope of this course, but you can look
up the &ldquo;path-compression&rdquo; heuristic if you are curious.</p></blockquote></blockquote></blockquote><p><div class="SIntrapara">To <span class="stt">union</span> two representatives, simply set the value of one representative&rsquo;s
representative to the other. </div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Again, why must we only ever union two
representatives, and not two arbitrary nodes?</div></p></blockquote></div></p><h5>3.4<tt>&nbsp;</tt><a name="(part._.Breadth-_and_depth-first_search)"></a>Breadth- and depth-first search</h5><p>As we worked through in class, breadth- and depth-first searches are very
closely related algorithms. The essential steps of the algorithm are the same;
the only difference is whether to use a queue or a stack.</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">HashMap&lt;String, Edge&gt; cameFromEdge;</span></p></td></tr><tr><td><p><span class="stt">???&lt;Node&gt; worklist; // A Queue or a Stack, depending on the algorithm</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">initialize the worklist to contain the starting node</span></p></td></tr><tr><td><p><span class="stt">While(the worklist is not empty)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Node next = the next item from the worklist</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If (next has already been processed)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">discard it</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Else If (next is the target):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return reconstruct(cameFromEdge, next);</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Else:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">For each neighbor n of next:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Add n to the worklist</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Record the edge (next-&gt;n) in the cameFromEdge map</span></p></td></tr></table></p><p>The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">cameFromEdge</span><span class="RktMeta"></span></span></span> map is used to record which edge of the graph was used
to get from an already-visited node to a not-yet-visited one.  This map is used
to reconstruct the path from the source to the given target node, simply by
following the edges <span class="emph">backward</span>, from the target node to the node that it
came from, and so on back to the source node. Unlike Kruskal&rsquo;s algorithm, the
worklist here is a collection of <span class="emph">nodes</span> (rather than edges).  Like the
union/find algorithm, there is a recursive traversal from one node to a
previous one, using node names as the keys into the auxiliary map that
accumulates the ongoing state of the algorithm.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="assignment8.html" title="backward to &quot;Assignment 8: Minesweeper&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Assignments.html" title="up to &quot;Assignments&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Pair_Programming_Overview.html" title="forward to &quot;Pair Programming Overview&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>